exports["WebpackPluginsFactory should generate client bundle (default)"] = "(function(define){const __ilc_script_url__ = document.currentScript.src;\nSystem.register([], function(__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {\n\n\n\treturn {\n\n\t\texecute: function() {\n\t\t\t__WEBPACK_DYNAMIC_EXPORT__(\n/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/global */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\tvar scriptUrl;\n/******/ \t\tif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\n/******/ \t\tvar document = __webpack_require__.g.document;\n/******/ \t\tif (!scriptUrl && document) {\n/******/ \t\t\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n/******/ \t\t\t\tscriptUrl = document.currentScript.src;\n/******/ \t\t\tif (!scriptUrl) {\n/******/ \t\t\t\tvar scripts = document.getElementsByTagName(\"script\");\n/******/ \t\t\t\tif(scripts.length) {\n/******/ \t\t\t\t\tvar i = scripts.length - 1;\n/******/ \t\t\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\t// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n/******/ \t\t// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\n/******/ \t\tif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\n/******/ \t\tscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n/******/ \t\t__webpack_require__.p = scriptUrl;\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nfunction resolveDirectory(urlString, rootDirectoryLevel = 1) {\n    // Our friend IE11 doesn't support new URL()\n    // https://github.com/single-spa/single-spa/issues/612\n    // https://gist.github.com/jlong/2428561\n    const a = document.createElement('a');\n    a.href = urlString;\n    /* istanbul ignore next */\n    const pathname = a.pathname[0] === '/' ? a.pathname : '/' + a.pathname;\n    let numDirsProcessed = 0;\n    let index = pathname.length;\n    while (numDirsProcessed !== rootDirectoryLevel && index >= 0) {\n        const char = pathname[--index];\n        if (char === '/') {\n            numDirsProcessed++;\n        }\n    }\n    if (numDirsProcessed !== rootDirectoryLevel) {\n        // tslint:disable-next-line:no-console\n        console.warn('ilc-webpack-plugins: rootDirectoryLevel (' +\n            rootDirectoryLevel +\n            ') is greater than the number of directories (' +\n            numDirsProcessed +\n            ') in the URL path ' +\n            urlString);\n    }\n    const finalPath = pathname.slice(0, index + 1) || '/';\n    return a.protocol + '//' + a.host + finalPath;\n}\n__webpack_require__.p  = resolveDirectory(__ilc_script_url__, 1);\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n\n\t\t\t);\n\t\t}\n\t};\n});\n})((window.ILC && window.ILC.define) || window.define);";

exports["WebpackPluginsFactory should generate client bundle (no public path)"] = "(function(define){const __ilc_script_url__ = document.currentScript.src;\nSystem.register([], function(__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {\n\n\n\treturn {\n\n\t\texecute: function() {\n\t\t\t__WEBPACK_DYNAMIC_EXPORT__(\n/******/ (() => { // webpackBootstrap\nvar __webpack_exports__ = {};\nconsole.log('TEST MODULE');\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n\n\t\t\t);\n\t\t}\n\t};\n});\n})((window.ILC && window.ILC.define) || window.define);";

exports["WebpackPluginsFactory should generate client bundle (rootDirectoryLevel)"] = "(function(define){const __ilc_script_url__ = document.currentScript.src;\nSystem.register([], function(__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {\n\n\n\treturn {\n\n\t\texecute: function() {\n\t\t\t__WEBPACK_DYNAMIC_EXPORT__(\n/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/global */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\tvar scriptUrl;\n/******/ \t\tif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\n/******/ \t\tvar document = __webpack_require__.g.document;\n/******/ \t\tif (!scriptUrl && document) {\n/******/ \t\t\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n/******/ \t\t\t\tscriptUrl = document.currentScript.src;\n/******/ \t\t\tif (!scriptUrl) {\n/******/ \t\t\t\tvar scripts = document.getElementsByTagName(\"script\");\n/******/ \t\t\t\tif(scripts.length) {\n/******/ \t\t\t\t\tvar i = scripts.length - 1;\n/******/ \t\t\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\t// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n/******/ \t\t// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\n/******/ \t\tif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\n/******/ \t\tscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n/******/ \t\t__webpack_require__.p = scriptUrl;\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nfunction resolveDirectory(urlString, rootDirectoryLevel = 1) {\n    // Our friend IE11 doesn't support new URL()\n    // https://github.com/single-spa/single-spa/issues/612\n    // https://gist.github.com/jlong/2428561\n    const a = document.createElement('a');\n    a.href = urlString;\n    /* istanbul ignore next */\n    const pathname = a.pathname[0] === '/' ? a.pathname : '/' + a.pathname;\n    let numDirsProcessed = 0;\n    let index = pathname.length;\n    while (numDirsProcessed !== rootDirectoryLevel && index >= 0) {\n        const char = pathname[--index];\n        if (char === '/') {\n            numDirsProcessed++;\n        }\n    }\n    if (numDirsProcessed !== rootDirectoryLevel) {\n        // tslint:disable-next-line:no-console\n        console.warn('ilc-webpack-plugins: rootDirectoryLevel (' +\n            rootDirectoryLevel +\n            ') is greater than the number of directories (' +\n            numDirsProcessed +\n            ') in the URL path ' +\n            urlString);\n    }\n    const finalPath = pathname.slice(0, index + 1) || '/';\n    return a.protocol + '//' + a.host + finalPath;\n}\n__webpack_require__.p  = resolveDirectory(__ilc_script_url__, 2);\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n\n\t\t\t);\n\t\t}\n\t};\n});\n})((window.ILC && window.ILC.define) || window.define);";

exports["WebpackPluginsFactory should generate server bundle (default)"] = "/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.p = \"\";\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\n\n        const pp = `${process.env.ILC_APP_PUBLIC_PATH}`;\n        if (!pp) {\n            throw new Error('IlcSdk: Unable to determine public path of the application');\n        }\n        __webpack_require__.p  = pp;\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\nmodule.exports = __webpack_exports__;\n/******/ })()\n;";

exports["WebpackPluginsFactory should generate server bundle (no public path)"] = "/******/ (() => { // webpackBootstrap\nvar __webpack_exports__ = {};\nconsole.log('TEST MODULE');\n\nmodule.exports = __webpack_exports__;\n/******/ })()\n;";

exports["WebpackPluginsFactory should generate server bundle (rootDirectoryLevel)"] = "/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.p = \"\";\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\n\n        const pp = `${process.env.ILC_APP_PUBLIC_PATH}`;\n        if (!pp) {\n            throw new Error('IlcSdk: Unable to determine public path of the application');\n        }\n        __webpack_require__.p  = pp;\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\nmodule.exports = __webpack_exports__;\n/******/ })()\n;";

exports["WebpackPluginsFactory should generate server bundle (ssrPublicPath)"] = "/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.p = \"\";\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\n\n        const pp = `ssr-path`;\n        if (!pp) {\n            throw new Error('IlcSdk: Unable to determine public path of the application');\n        }\n        __webpack_require__.p  = pp;\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\nmodule.exports = __webpack_exports__;\n/******/ })()\n;";

