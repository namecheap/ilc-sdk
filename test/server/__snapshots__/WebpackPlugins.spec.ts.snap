exports["WebpackPluginsFactory should generate client bundle (default)"] = "(function(define){const __ilc_script_url__ = document.currentScript.src;\nSystem.register([], function(__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {\n\n\n\treturn {\n\n\t\texecute: function() {\n\t\t\t__WEBPACK_DYNAMIC_EXPORT__(\n/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/global */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\tvar scriptUrl;\n/******/ \t\tif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\n/******/ \t\tvar document = __webpack_require__.g.document;\n/******/ \t\tif (!scriptUrl && document) {\n/******/ \t\t\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n/******/ \t\t\t\tscriptUrl = document.currentScript.src;\n/******/ \t\t\tif (!scriptUrl) {\n/******/ \t\t\t\tvar scripts = document.getElementsByTagName(\"script\");\n/******/ \t\t\t\tif(scripts.length) {\n/******/ \t\t\t\t\tvar i = scripts.length - 1;\n/******/ \t\t\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\t// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n/******/ \t\t// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\n/******/ \t\tif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\n/******/ \t\tscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n/******/ \t\t__webpack_require__.p = scriptUrl;\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nfunction resolveDirectory(e,t=1){var r=document.createElement(\"a\"),o=(r.href=e,\"/\"===r.pathname[0]?r.pathname:\"/\"+r.pathname);let n=0,a=o.length;for(;n!==t&&0<=a;)\"/\"===o[--a]&&n++;n!==t&&console.warn(\"ilc-webpack-plugins: rootDirectoryLevel (\"+t+\") is greater than the number of directories (\"+n+\") in the URL path \"+e);e=o.slice(0,a+1)||\"/\";return r.protocol+\"//\"+r.host+e}\n            __webpack_require__.p  = resolveDirectory(__ilc_script_url__, 1);\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n\n\t\t\t);\n\t\t}\n\t};\n});\n})((window.ILC && window.ILC.define) || window.define);";

exports["WebpackPluginsFactory should generate client bundle (no public path)"] = "(function(define){const __ilc_script_url__ = document.currentScript.src;\nSystem.register([], function(__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {\n\n\n\treturn {\n\n\t\texecute: function() {\n\t\t\t__WEBPACK_DYNAMIC_EXPORT__(\n/******/ (() => { // webpackBootstrap\nvar __webpack_exports__ = {};\nconsole.log('TEST MODULE');\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n\n\t\t\t);\n\t\t}\n\t};\n});\n})((window.ILC && window.ILC.define) || window.define);";

exports["WebpackPluginsFactory should generate client bundle (rootDirectoryLevel)"] = "(function(define){const __ilc_script_url__ = document.currentScript.src;\nSystem.register([], function(__WEBPACK_DYNAMIC_EXPORT__, __system_context__) {\n\n\n\treturn {\n\n\t\texecute: function() {\n\t\t\t__WEBPACK_DYNAMIC_EXPORT__(\n/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/global */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\tvar scriptUrl;\n/******/ \t\tif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\n/******/ \t\tvar document = __webpack_require__.g.document;\n/******/ \t\tif (!scriptUrl && document) {\n/******/ \t\t\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n/******/ \t\t\t\tscriptUrl = document.currentScript.src;\n/******/ \t\t\tif (!scriptUrl) {\n/******/ \t\t\t\tvar scripts = document.getElementsByTagName(\"script\");\n/******/ \t\t\t\tif(scripts.length) {\n/******/ \t\t\t\t\tvar i = scripts.length - 1;\n/******/ \t\t\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\t// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n/******/ \t\t// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\n/******/ \t\tif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\n/******/ \t\tscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n/******/ \t\t__webpack_require__.p = scriptUrl;\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nfunction resolveDirectory(e,t=1){var r=document.createElement(\"a\"),o=(r.href=e,\"/\"===r.pathname[0]?r.pathname:\"/\"+r.pathname);let n=0,a=o.length;for(;n!==t&&0<=a;)\"/\"===o[--a]&&n++;n!==t&&console.warn(\"ilc-webpack-plugins: rootDirectoryLevel (\"+t+\") is greater than the number of directories (\"+n+\") in the URL path \"+e);e=o.slice(0,a+1)||\"/\";return r.protocol+\"//\"+r.host+e}\n            __webpack_require__.p  = resolveDirectory(__ilc_script_url__, 2);\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\n/******/ \treturn __webpack_exports__;\n/******/ })()\n\n\t\t\t);\n\t\t}\n\t};\n});\n})((window.ILC && window.ILC.define) || window.define);";

exports["WebpackPluginsFactory should generate server bundle (default)"] = "/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.p = \"\";\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\n\n        const pp = `${process.env.ILC_APP_PUBLIC_PATH}`;\n        if (!pp) {\n            throw new Error('IlcSdk: Unable to determine public path of the application');\n        }\n        __webpack_require__.p  = pp;\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\nmodule.exports = __webpack_exports__;\n/******/ })()\n;";

exports["WebpackPluginsFactory should generate server bundle (no public path)"] = "/******/ (() => { // webpackBootstrap\nvar __webpack_exports__ = {};\nconsole.log('TEST MODULE');\n\nmodule.exports = __webpack_exports__;\n/******/ })()\n;";

exports["WebpackPluginsFactory should generate server bundle (rootDirectoryLevel)"] = "/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.p = \"\";\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\n\n        const pp = `${process.env.ILC_APP_PUBLIC_PATH}`;\n        if (!pp) {\n            throw new Error('IlcSdk: Unable to determine public path of the application');\n        }\n        __webpack_require__.p  = pp;\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\nmodule.exports = __webpack_exports__;\n/******/ })()\n;";

exports["WebpackPluginsFactory should generate server bundle (ssrPublicPath)"] = "/******/ (() => { // webpackBootstrap\n/******/ \t// The require scope\n/******/ \tvar __webpack_require__ = {};\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/publicPath */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.p = \"\";\n/******/ \t})();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\n\n        const pp = `ssr-path`;\n        if (!pp) {\n            throw new Error('IlcSdk: Unable to determine public path of the application');\n        }\n        __webpack_require__.p  = pp;\n})();\n\n// This entry needs to be wrapped in an IIFE because it needs to be isolated against other entry modules.\n(() => {\nconsole.log('TEST MODULE');\n\n})();\n\nmodule.exports = __webpack_exports__;\n/******/ })()\n;";

